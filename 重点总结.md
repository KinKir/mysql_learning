**避免长事务**

> 为什么尽量不要使用长事务。长事务意味着系统里面会存在很老的事务视图，在这个事务提交之前，回滚记录都要保留，这会导致大量占用存储空间。除此之外，长事务还占用锁资源，可能会拖垮库。

> 在开发过程中，尽可能的减小事务范围，少用长事务，如果无法避免，保证逻辑日志空间足够用，并且支持动态日志空间增长。监控Innodb_trx表，发现长事务报警。

**使用前缀索引区分度不好的时候怎么办**
* 第一种方式是使用倒序存储。

* mysql> select field_list from t where id_card = reverse('input_id_card_string');

* 第二种方式是使用hash字段

**为什么表数据删除空间不减小**

* 表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数innodb_file_per_table控制的
* 这个参数设置为OFF表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；

* 这个参数设置为ON表示的是，每个InnoDB表数据存储在一个以 .ibd为后缀的文件中。
> 从MySQL 5.6.6版本开始，它的默认值就是ON了
* 删除一个数据的时候 这个数据会被标记已删除(可复用)，delete命令只是把数据标记为"可复用"。

**解决的办法为重建表**
* 从MySQL 5.6版本开始，alter table t engine = InnoDB（也就是recreate）;
* analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了MDL读锁；
* optimize table t 等于recreate+analyze。

**磁盘压力小，数据库出现间歇性的性能下跌**
* redo log设置太小

> 在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。

**redo log一般设置多大？**
* 如果是现在常见的几个TB的磁盘的话，就不要太小气了，直接将redo log设置为4个文件、每个文件1GB吧。

**count的优化**
> 可以把一个表的总数单独拿出来存到一个表中
* 对于count(主键id)来说，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加
* 对于count(1)来说，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。
> 按照效率排序的话，count(字段)<count(主键id)<count(1)≈count(\*)，所以我建议你，尽量使用count(*)。
### InnoDB 是如何解决幻读
* 引入间隙锁(Gap Lock) 锁的是两个值之间的空隙
* 间隙锁是前开后闭空间 间隙锁之间不冲突
* next-key lock  可重复读生效
### 判断一个数据库有没有出问题
* 随便去更新个表




